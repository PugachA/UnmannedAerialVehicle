Конфигурация железа:
Функции работы замера длины импульса и генерации для серв завязаны на конфигурацию таймера
Для замера:
1. Выставить на канале input capture direct mode
2. Предделитель выставляется из расчета: 1 тик таймера = 1 Мгц (предделитель=(частота_шины/1 000 000) - 1)
3. Период счетчика не важен для режима захвата импульса. Пусть тикает до конца
4. В кубе разрешить прерывания для этого таймера
Для генерации импульсов
1. Выставить на канале PWM generation
2. Предделитель аналогично замеру длины импульса
3. Counter mode = Up
4. Counter period = 22 000 (чуть больше периода ШИМа для 20 000 мкС = 50 Гц)
5. Остальное по умолчанию
6. Разрешить прерывания

Конфигурация в проге:
В main:
1. Подключаем либу: #include "RcChannel/RcChannel.h"
2. Экстерналим переменные (объекты создаются в cpp файле либы): extern RcChannel thr_rc, elev_rc, ail_rc, rud_rc, switch_rc, slider_rc;
3. Регистрируем колбэки:
	HAL_TIM_RegisterCallback(&htim2, HAL_TIM_IC_CAPTURE_CB_ID, IcHandlerTim2);
IcHandlerTim2 - указатель на функцию, определены в cpp файле либы. В них вызывается функция рассчета длины импульса зависимо от канала
по которому пришлом прерывания. Можно убрать из свитча каналы, которые не используются. Можно оставить как есть т.к. он не зайдет в иф если на канал ничего
не будет приходить. Функцию можно назвать как хочется. Т.к. она полюбому привязана к таймеру при регистрации и в неё он передается.
4. Запускаем режим захвата импульса зависит от вашего таймера и канала: HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1); 
5. Получаем значения длины импульса где-то в проге (thr_rc - просто пример объекта): thr_rc.getPulseWidth();
Для генерации импульсов:
1. Запускаем генерацию шима на нужном таймере и канале: HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);//PA6 thr output
2. Создаем объект: Servo 	thr_servo(htim3.Instance, 1) (таймер и номер канала передаем)
3. Генерим значение длины импульса в мкС thr_servo.setPositionMicroSeconds(длина импульса в мкС);

В HAL либах:
1. Открываем файл: Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim.h
2. Где-то вверху прописываем: #define USE_HAL_TIM_REGISTER_CALLBACKS 1
3. Операции надо повторять после каждой перегенерации в кубе

В файле RcChannel.cpp:
1. Экстерналим указатели на свои таймеры: extern TIM_HandleTypeDef htim2, htim5; 
2. Создаем нужные нам объекты: указатель и номер канала важны (первые 2 параметра). channel_min_value и channel_mix_value нужны только для определения положения
тумблеров и в принципе могут быть заданы рандомно если не нужны или взять как те что уже есть в либе.



	